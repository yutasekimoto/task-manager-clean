<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>To Doç®¡ç†</title>
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-title" content="To Doç®¡ç†">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif; background: linear-gradient(135deg, #2d5a27 0%, #1e3f1a 100%); min-height: 100vh; padding: 20px; }
        .container { max-width: 500px; margin: 0 auto; }
        .header { text-align: center; color: white; margin-bottom: 30px; position: relative; }
        .header h1 { font-size: 2.5em; margin-bottom: 10px; }
        .version { position: absolute; top: 0; right: 0; font-size: 0.8em; color: rgba(255,255,255,0.7); }
        .stats { display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px; margin-bottom: 25px; }
        .stat { background: rgba(255,255,255,0.9); padding: 15px; border-radius: 15px; text-align: center; cursor: pointer; transition: all 0.2s ease; }
        .stat:hover { transform: translateY(-2px); box-shadow: 0 4px 8px rgba(0,0,0,0.1); }
        .stat-number { font-size: 1.8em; font-weight: bold; color: #333; }
        .stat-label { font-size: 0.9em; color: #666; margin-top: 5px; }
        .add-task { background: rgba(255,255,255,0.95); padding: 20px; border-radius: 20px; margin-bottom: 25px; display: flex; gap: 10px; }
        .add-task input { flex: 1; padding: 15px; border: none; border-radius: 15px; font-size: 16px; background: #f8f9fa; }
        .add-task button { padding: 15px 25px; background: #667eea; color: white; border: none; border-radius: 15px; font-weight: bold; cursor: pointer; }
        .filters { display: flex; gap: 10px; margin-bottom: 20px; overflow-x: auto; }
        .filter { padding: 10px 20px; background: rgba(255,255,255,0.2); color: white; border: none; border-radius: 25px; cursor: pointer; white-space: nowrap; }
        .filter.active { background: rgba(255,255,255,0.9); color: #667eea; }
        .view-switcher { display: flex; gap: 5px; margin-bottom: 15px; }
        .view-btn { padding: 8px 16px; background: rgba(255,255,255,0.2); color: white; border: none; border-radius: 20px; cursor: pointer; font-size: 14px; }
        .view-btn.active { background: rgba(255,255,255,0.9); color: #667eea; }
        .date-picker { display: none; margin-bottom: 15px; }
        .date-picker.show { display: flex; }
        .date-picker input { padding: 8px 12px; border: 1px solid rgba(255,255,255,0.3); border-radius: 15px; background: rgba(255,255,255,0.9); color: #333; }
        .date-picker label { color: white; margin-right: 10px; font-size: 14px; display: flex; align-items: center; }
        .tasks { space: 15px; }
        .task { background: rgba(255,255,255,0.95); padding: 12px 16px; margin-bottom: 8px; border-radius: 12px; display: flex; align-items: center; gap: 12px; cursor: pointer; transition: all 0.2s ease; touch-action: manipulation; }
        .task:hover { transform: translateY(-2px); box-shadow: 0 4px 12px rgba(0,0,0,0.15); }
        .task.progress { background: rgba(255, 183, 77, 0.8); border-left: 4px solid #ff9800; box-shadow: 0 2px 4px rgba(255, 152, 0, 0.2); }
        .task.paused { background: rgba(173, 216, 230, 0.8); border-left: 4px solid #87ceeb; box-shadow: 0 2px 4px rgba(173, 216, 230, 0.2); }
        .task.dragging { opacity: 0.5; transform: rotate(2deg); z-index: 1000; }
        .task.drag-over { border-top: 3px solid #667eea; }
        .task.drag-target-above { margin-top: 60px; transition: margin-top 0.2s ease; }
        .task.drag-target-below { margin-bottom: 60px; transition: margin-bottom 0.2s ease; }
        .task-actions button { touch-action: manipulation; }
        .task.completed { opacity: 0.6; }
        .task.completed .task-text { text-decoration: line-through; }
        .drag-handle { width: 20px; height: 20px; cursor: move; flex-shrink: 0; display: flex; align-items: center; justify-content: center; color: #999; font-size: 16px; }
        .drag-handle:hover { color: #667eea; }
        .memo-icon { width: 20px; height: 20px; cursor: pointer; flex-shrink: 0; display: flex; align-items: center; justify-content: center; color: #999; font-size: 14px; transition: color 0.2s ease; }
        .memo-icon:hover { color: #667eea; }
        .memo-icon.has-memo { color: #ffc107; }
        .memo-icon.has-memo:hover { color: #ff9800; }
        .schedule-icon { width: 16px; height: 16px; flex-shrink: 0; display: flex; align-items: center; justify-content: center; color: #28a745; font-size: 12px; margin-left: 4px; }
        .task-content { flex: 1; }
        .task-text { font-size: 15px; cursor: pointer; padding: 2px 4px; border-radius: 4px; transition: background 0.2s ease; }
        .task-text:hover { background: rgba(0,0,0,0.05); }
        .task-text.editing { background: #fff; border: 2px solid #667eea; outline: none; }
        .task-actions { display: flex; gap: 8px; }
        .task-actions button { width: 32px; height: 32px; background: #f8f9fa; border: none; cursor: pointer; border-radius: 50%; color: #6c757d; font-size: 14px; display: flex; align-items: center; justify-content: center; transition: all 0.2s ease; }
        .task-actions button:hover { transform: translateY(-2px); box-shadow: 0 4px 8px rgba(0,0,0,0.1); }
        .task-actions .start { color: #007bff; }
        .task-actions .start:hover { background: #e3f2fd; }
        .task-actions .complete { color: #28a745; }
        .task-actions .complete:hover { background: #e8f5e8; }
        .task-actions .delete { color: #dc3545; }
        .task-actions .delete:hover { background: #fdeaea; }
        .task-actions .back { color: #fd7e14; }
        .task-actions .back:hover { background: #fff3cd; }
        .task-actions .pause { color: #17a2b8; }
        .task-actions .pause:hover { background: #d1ecf1; }
        .empty { text-align: center; padding: 40px; color: rgba(255,255,255,0.8); }
        .sync-indicator { 
            position: fixed; 
            top: 20px; 
            right: 20px; 
            background: rgba(255,255,255,0.9); 
            padding: 8px 12px; 
            border-radius: 20px; 
            font-size: 12px; 
            opacity: 0; 
            transition: opacity 0.3s ease; 
            z-index: 1000;
            cursor: pointer;
        }
        .sync-indicator.show { opacity: 1; }
        .sync-indicator.error { background: #f8d7da; color: #721c24; }
        .sync-indicator.success { background: #d4edda; color: #155724; }
        .sync-indicator.local-only { background: #fff3cd; color: #856404; }
        
        .debug-panel {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 10px;
            border-radius: 10px;
            font-size: 11px;
            font-family: monospace;
            max-width: 300px;
            z-index: 1000;
            display: none;
        }
        .debug-panel.show { display: block; }
        
        .memo-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 10000; display: none; align-items: center; justify-content: center; }
        .memo-overlay.show { display: flex; }
        .memo-modal { background: white; width: 90%; max-width: 500px; max-height: 80%; border-radius: 15px; overflow: hidden; display: flex; flex-direction: column; }
        .memo-header { padding: 20px; background: #667eea; color: white; display: flex; justify-content: between; align-items: center; }
        .memo-title { font-size: 18px; font-weight: bold; flex: 1; }
        .memo-close { background: none; border: none; color: white; font-size: 24px; cursor: pointer; padding: 0; width: 30px; height: 30px; display: flex; align-items: center; justify-content: center; }
        .memo-content { flex: 1; padding: 20px; overflow-y: auto; }
        .memo-editor { width: 100%; height: 250px; border: 1px solid #ddd; border-radius: 8px; padding: 15px; font-size: 16px; font-family: inherit; resize: vertical; }
        .memo-toolbar { display: flex; gap: 10px; margin-bottom: 15px; flex-wrap: wrap; }
        .schedule-section { margin-bottom: 20px; padding: 15px; background: #f8f9fa; border-radius: 8px; }
        .schedule-section h4 { margin: 0 0 10px 0; font-size: 14px; color: #666; }
        .schedule-inputs { display: flex; gap: 10px; flex-wrap: wrap; }
        .schedule-inputs input { padding: 8px; border: 1px solid #ddd; border-radius: 6px; font-size: 14px; }
        .schedule-inputs input[type="date"] { flex: 1; min-width: 150px; }
        .schedule-inputs input[type="time"] { flex: 1; min-width: 120px; }
        .schedule-clear { background: #dc3545; color: white; border: none; padding: 8px 12px; border-radius: 6px; cursor: pointer; font-size: 12px; }
        .schedule-clear:hover { background: #c82333; }
        .memo-toolbar button { padding: 8px 12px; background: #f8f9fa; border: 1px solid #ddd; border-radius: 6px; cursor: pointer; font-size: 12px; }
        .memo-toolbar button:hover { background: #e9ecef; }
        .memo-toolbar button.active { background: #667eea; color: white; }
        .memo-actions { padding: 20px; border-top: 1px solid #eee; display: flex; gap: 10px; justify-content: flex-end; }
        .memo-actions button { padding: 10px 20px; border: none; border-radius: 8px; cursor: pointer; font-weight: bold; }
        .memo-save { background: #667eea; color: white; }
        .memo-cancel { background: #f8f9fa; color: #666; }
        
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>To Do</h1>
            <div class="version">v2025.1.25</div>
        </div>

        <div class="stats">
            <div class="stat" onclick="setFilter('all')">
                <div class="stat-number" id="totalTasks">0</div>
                <div class="stat-label">ã‚¢ã‚¯ãƒ†ã‚£ãƒ–</div>
            </div>
            <div class="stat" onclick="setFilter('progress')">
                <div class="stat-number" id="progressTasks">0</div>
                <div class="stat-label">é€²è¡Œä¸­</div>
            </div>
            <div class="stat" onclick="setFilter('completed')">
                <div class="stat-number" id="completedTasks">0</div>
                <div class="stat-label">å®Œäº†</div>
            </div>
        </div>

        <div class="add-task">
            <input type="text" id="newTask" placeholder="æ–°ã—ã„ã‚¿ã‚¹ã‚¯ã‚’å…¥åŠ›...">
            <button onclick="addTask()">è¿½åŠ </button>
        </div>

        <div class="view-switcher">
            <button class="view-btn active" onclick="switchView('all')">å…¨ã‚¿ã‚¹ã‚¯</button>
            <button class="view-btn" onclick="switchView('date')">æ—¥ä»˜åˆ¥</button>
        </div>
        
        <div class="date-picker" id="datePicker">
            <label for="viewDate">ğŸ“… æ—¥ä»˜é¸æŠ:</label>
            <input type="date" id="viewDate" onchange="setDateFilter()" />
        </div>
        
        <div class="filters" id="statusFilters">
            <button class="filter active" onclick="setFilter('all')">ã‚¢ã‚¯ãƒ†ã‚£ãƒ–</button>
            <button class="filter" onclick="setFilter('progress')">é€²è¡Œä¸­</button>
            <button class="filter" onclick="setFilter('completed')">å®Œäº†</button>
        </div>

        <div class="tasks" id="taskList"></div>
    </div>

    <!-- ãƒ¡ãƒ¢ç·¨é›†ãƒ¢ãƒ¼ãƒ€ãƒ« -->
    <div class="memo-overlay" id="memoOverlay">
        <div class="memo-modal">
            <div class="memo-header">
                <div class="memo-title" id="memoTaskTitle">ã‚¿ã‚¹ã‚¯å</div>
                <button class="memo-close" onclick="closeMemoEditor()">Ã—</button>
            </div>
            <div class="memo-content">
                <div class="schedule-section">
                    <h4>ğŸ“… å®Ÿæ–½äºˆå®šæ—¥æ™‚</h4>
                    <div class="schedule-inputs">
                        <input type="date" id="scheduleDate" min="" />
                        <input type="time" id="scheduleTime" />
                        <button class="schedule-clear" onclick="clearSchedule()">ã‚¯ãƒªã‚¢</button>
                    </div>
                </div>
                <div class="memo-toolbar">
                    <button onclick="insertMemoFormat('bullet')" title="ç®‡æ¡æ›¸ã">â€¢ ç®‡æ¡æ›¸ã</button>
                    <button onclick="insertMemoFormat('number')" title="ç•ªå·ä»˜ããƒªã‚¹ãƒˆ">1. ç•ªå·ãƒªã‚¹ãƒˆ</button>
                    <button onclick="insertMemoFormat('checkbox')" title="ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹">â˜ ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹</button>
                </div>
                <textarea class="memo-editor" id="memoEditor" placeholder="ãƒ¡ãƒ¢ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„..."></textarea>
            </div>
            <div class="memo-actions">
                <button class="memo-cancel" onclick="closeMemoEditor()">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
                <button class="memo-save" onclick="saveMemo()">ä¿å­˜</button>
            </div>
        </div>
    </div>

    <div class="sync-indicator" id="syncIndicator" onclick="toggleDebugPanel()"></div>
    <div class="debug-panel" id="debugPanel">
        <div><strong>ãƒ‡ãƒãƒƒã‚°æƒ…å ±</strong></div>
        <div>User ID: <span id="debugUserId">-</span></div>
        <div>Supabaseæ¥ç¶š: <span id="debugSupabase">-</span></div>
        <div>ãƒ­ãƒ¼ã‚«ãƒ«ã‚¿ã‚¹ã‚¯æ•°: <span id="debugLocalTasks">0</span></div>
        <div>åŒæœŸå¾…ã¡ã‚¿ã‚¹ã‚¯: <span id="debugPendingSync">0</span></div>
        <div>æœ€çµ‚åŒæœŸ: <span id="debugLastSync">-</span></div>
        <button onclick="forceSync()" style="margin-top: 5px; padding: 2px 8px; font-size: 10px;">å¼·åˆ¶åŒæœŸ</button>
        <button onclick="clearLocalData()" style="margin-top: 2px; padding: 2px 8px; font-size: 10px; background: #dc3545; color: white; border: none;">ãƒ­ãƒ¼ã‚«ãƒ«å‰Šé™¤</button>
        <button onclick="playNotificationSound()" style="margin-top: 2px; padding: 2px 8px; font-size: 10px; background: #28a745; color: white; border: none;">ğŸ””éŸ³ãƒ†ã‚¹ãƒˆ</button>
    </div>
    

    <script src="https://unpkg.com/@supabase/supabase-js@2"></script>
    <script>
        console.log('ToDoã‚¢ãƒ—ãƒª ver.2025.1.25 é–‹å§‹');
        
        // Supabaseè¨­å®š
        let supabase = null;
        let currentUser = null;
        
        try {
            const SUPABASE_URL = 'https://hsekpmpboawozvtuwscf.supabase.co';
            const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImhzZWtwbXBib2F3b3p2dHV3c2NmIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTE4OTI5NDAsImV4cCI6MjA2NzQ2ODk0MH0.IgGMu0tJYhnTtW1GoDcf0qk64Yhwyp6_1ZRl2S7b3ns';
            
            if (window.supabase && window.supabase.createClient && SUPABASE_URL && SUPABASE_ANON_KEY) {
                supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
                console.log('SupabaseåˆæœŸåŒ–æˆåŠŸ');
                
                // èªè¨¼çŠ¶æ…‹ã®ç›£è¦–
                supabase.auth.onAuthStateChange((event, session) => {
                    currentUser = session?.user || null;
                    if (currentUser) {
                        userId = currentUser.id;
                        console.log('ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ­ã‚°ã‚¤ãƒ³:', userId);
                        loadTasks();
                    } else {
                        console.log('ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ­ã‚°ã‚¢ã‚¦ãƒˆ');
                        signInAnonymously();
                    }
                });
                
                // åˆæœŸèªè¨¼ç¢ºèª
                supabase.auth.getSession().then(({ data: { session } }) => {
                    currentUser = session?.user || null;
                    if (currentUser) {
                        userId = currentUser.id;
                        console.log('æ—¢å­˜ã‚»ãƒƒã‚·ãƒ§ãƒ³:', userId);
                    } else {
                        signInAnonymously();
                    }
                });
                
            } else {
                console.warn('Supabaseãƒ©ã‚¤ãƒ–ãƒ©ãƒªãŒèª­ã¿è¾¼ã¾ã‚Œã¦ã„ã¾ã›ã‚“');
                signInAnonymously();
            }
        } catch (error) {
            console.error('SupabaseåˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼:', error);
        }
        
        // åŒ¿åãƒ­ã‚°ã‚¤ãƒ³
        async function signInAnonymously() {
            if (!supabase) return;
            
            try {
                // æ—¢å­˜ã®åŒ¿åã‚»ãƒƒã‚·ãƒ§ãƒ³ãŒã‚ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
                let storedAnonId = localStorage.getItem('todo_anon_user_id');
                
                if (!storedAnonId) {
                    // æ–°ã—ã„åŒ¿åãƒ¦ãƒ¼ã‚¶ãƒ¼IDã‚’ç”Ÿæˆ
                    storedAnonId = 'anon_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                    localStorage.setItem('todo_anon_user_id', storedAnonId);
                }
                
                userId = storedAnonId;
                console.log('åŒ¿åãƒ¦ãƒ¼ã‚¶ãƒ¼ID:', userId);
                loadTasks();
                
            } catch (error) {
                console.error('åŒ¿åãƒ­ã‚°ã‚¤ãƒ³ã‚¨ãƒ©ãƒ¼:', error);
                userId = generateUserId(); // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
                loadTasks();
            }
        }

        // ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³çŠ¶æ…‹
        let tasks = [];
        let currentFilter = 'all';
        let currentView = 'all'; // 'all' or 'date'
        let selectedDate = null;
        let userId = null; // Supabaseèªè¨¼å¾Œã«è¨­å®š
        let draggedTaskIndex = null;
        let pendingSync = new Set();
        let syncTimer = null;
        let currentEditingMemo = null;

        // ãƒ‡ãƒã‚¤ã‚¹åˆ¤å®š
        const isMobile = /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || 
                         ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);

        // ã‚¹ãƒãƒ›å¯¾å¿œ: ã‚¿ãƒƒãƒã‚¤ãƒ™ãƒ³ãƒˆç”¨å¤‰æ•°
        let touchStartY = 0;
        let touchCurrentY = 0;
        let isTouching = false;

        function generateUserId() {
            const id = 'user_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
            localStorage.setItem('todo_user_id', id);
            return id;
        }

        function showSyncIndicator(message, isError = false, isSuccess = false, isLocalOnly = false) {
            const indicator = document.getElementById('syncIndicator');
            if (indicator) {
                indicator.textContent = message;
                let className = 'sync-indicator show';
                if (isError) className += ' error';
                else if (isSuccess) className += ' success';
                else if (isLocalOnly) className += ' local-only';
                
                indicator.className = className;
                setTimeout(() => {
                    indicator.classList.remove('show');
                }, 3000);
            }
            updateDebugInfo();
        }
        
        function updateDebugInfo() {
            document.getElementById('debugUserId').textContent = userId || '-';
            document.getElementById('debugSupabase').textContent = supabase ? 'âœ“æ¥ç¶š' : 'âœ—æœªæ¥ç¶š';
            document.getElementById('debugLocalTasks').textContent = tasks.length;
            document.getElementById('debugPendingSync').textContent = pendingSync.size;
            document.getElementById('debugLastSync').textContent = new Date().toLocaleTimeString();
        }
        
        function toggleDebugPanel() {
            const panel = document.getElementById('debugPanel');
            panel.classList.toggle('show');
            updateDebugInfo();
        }
        
        async function forceSync() {
            showSyncIndicator('å¼·åˆ¶åŒæœŸä¸­...');
            await performBatchSync();
        }
        
        function clearLocalData() {
            if (confirm('ãƒ­ãƒ¼ã‚«ãƒ«ãƒ‡ãƒ¼ã‚¿ã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ')) {
                if (userId) {
                    localStorage.removeItem('taskflow_tasks_' + userId);
                }
                localStorage.removeItem('todo_anon_user_id');
                tasks = [];
                renderTasks();
                showSyncIndicator('ãƒ­ãƒ¼ã‚«ãƒ«ãƒ‡ãƒ¼ã‚¿å‰Šé™¤å®Œäº†', false, false, true);
                location.reload();
            }
        }
        

        function checkAndExtendOverdueTasks() {
            const today = new Date();
            today.setHours(0, 0, 0, 0); // æ™‚åˆ»ã‚’ãƒªã‚»ãƒƒãƒˆ
            
            let hasUpdates = false;
            
            tasks.forEach(task => {
                if (task.scheduledDate && (task.status === 'todo' || task.status === 'progress' || task.status === 'paused')) {
                    const scheduledDate = new Date(task.scheduledDate);
                    scheduledDate.setHours(0, 0, 0, 0);
                    
                    // è¨­å®šæ—¥ãŒä»Šæ—¥ã‚ˆã‚Šå‰ã®å ´åˆ
                    if (scheduledDate < today) {
                        const originalTime = new Date(task.scheduledDate);
                        const newDate = new Date(today);
                        newDate.setDate(newDate.getDate() + 1); // 1æ—¥å¾Œã‚å€’ã—
                        newDate.setHours(originalTime.getHours(), originalTime.getMinutes(), 0, 0);
                        
                        task.scheduledDate = newDate.toISOString();
                        pendingSync.add(task.id);
                        hasUpdates = true;
                        
                        console.log(`ã‚¿ã‚¹ã‚¯ "${task.text}" ã®æœŸé™ã‚’å»¶æœŸ: ${newDate.toLocaleDateString()}`);
                    }
                }
            });
            
            if (hasUpdates) {
                scheduleBatchSync();
                renderTasks();
            }
        }
        
        async function loadTasks() {
            if (!userId) {
                console.log('userIdãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚ã‚¹ã‚­ãƒƒãƒ—');
                return;
            }
            
            try {
                console.log('ãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿é–‹å§‹, userId:', userId);
                
                // ãƒ­ãƒ¼ã‚«ãƒ«ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã‹ã‚‰å³åº§ã«èª­ã¿è¾¼ã¿
                const localTasks = localStorage.getItem('taskflow_tasks_' + userId);
                if (localTasks) {
                    tasks = JSON.parse(localTasks);
                    console.log('ãƒ­ãƒ¼ã‚«ãƒ«ãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿:', tasks.length, 'ä»¶');
                    renderTasks();
                }

                // SupabaseãŒåˆ©ç”¨å¯èƒ½ãªå ´åˆã®ã¿ã‚¯ãƒ©ã‚¦ãƒ‰åŒæœŸ
                if (supabase) {
                    console.log('Supabaseã‹ã‚‰ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—ä¸­...');
                    const { data, error } = await supabase
                        .from('tasks')
                        .select('*')
                        .eq('user_id', userId)
                        .order('order_index', { ascending: true });

                    if (error) {
                        console.error('Supabaseèª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼:', error);
                        
                        // ãƒ†ãƒ¼ãƒ–ãƒ«ãŒå­˜åœ¨ã—ãªã„å ´åˆã®è©³ç´°ãƒ­ã‚°
                        console.log('Supabaseã‚¨ãƒ©ãƒ¼è©³ç´°:', error);
                        if (error.code === 'PGRST116' || error.message.includes('relation "tasks" does not exist') || error.code === '42P01') {
                            console.log('tasksãƒ†ãƒ¼ãƒ–ãƒ«ãŒå­˜åœ¨ã—ã¾ã›ã‚“ã€‚ãƒ­ãƒ¼ã‚«ãƒ«ä¿å­˜ã«åˆ‡ã‚Šæ›¿ãˆã¾ã™ã€‚');
                            showSyncIndicator('ãƒ†ãƒ¼ãƒ–ãƒ«æœªä½œæˆã€ãƒ­ãƒ¼ã‚«ãƒ«ä¿å­˜', false, false, true);
                            showTableCreationInfo();
                        } else {
                            showSyncIndicator('åŒæœŸã‚¨ãƒ©ãƒ¼: ' + error.message, true);
                        }
                    } else if (data && data.length > 0) {
                        console.log('Supabaseãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿:', data.length, 'ä»¶');
                        tasks = data.map(item => ({
                            id: item.id,
                            text: item.text,
                            status: item.status,
                            createdAt: item.created_at,
                            completedAt: item.completed_at,
                            order: item.order_index,
                            memo: item.memo || '',
                            scheduledDate: item.scheduled_date || null
                        }));
                        renderTasks();
                        localStorage.setItem('taskflow_tasks_' + userId, JSON.stringify(tasks));
                        showSyncIndicator('SupabaseåŒæœŸå®Œäº†', false, true);
                    } else {
                        console.log('Supabaseã«ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“');
                    }
                }
                console.log('ãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿å®Œäº†');
                
                // æœŸé™åˆ‡ã‚Œã‚¿ã‚¹ã‚¯ã®ãƒã‚§ãƒƒã‚¯ã¨å»¶æœŸ
                checkAndExtendOverdueTasks();
            } catch (error) {
                console.error('loadTasks ã‚¨ãƒ©ãƒ¼:', error);
                showSyncIndicator('åŒæœŸã‚¨ãƒ©ãƒ¼', true);
            }
        }
        
        // Supabaseãƒ†ãƒ¼ãƒ–ãƒ«ä½œæˆãŒå¿…è¦ãªå ´åˆã®æƒ…å ±è¡¨ç¤º
        function showTableCreationInfo() {
            const message = `
Supabaseã«tasksãƒ†ãƒ¼ãƒ–ãƒ«ã‚’ä½œæˆã—ã¦ãã ã•ã„ï¼š

1. https://supabase.com ã«ã‚¢ã‚¯ã‚»ã‚¹
2. ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚’é¸æŠ
3. SQL Editorã§ä»¥ä¸‹ã‚’å®Ÿè¡Œï¼š

CREATE TABLE tasks (
  id BIGINT PRIMARY KEY,
  user_id TEXT NOT NULL,
  text TEXT NOT NULL,
  status TEXT NOT NULL DEFAULT 'todo',
  created_at TIMESTAMPTZ DEFAULT NOW(),
  completed_at TIMESTAMPTZ,
  order_index INTEGER DEFAULT 0
);

-- Row Level Security (RLS) ã‚’æœ‰åŠ¹åŒ–
ALTER TABLE tasks ENABLE ROW LEVEL SECURITY;

-- ãƒ¦ãƒ¼ã‚¶ãƒ¼ã¯è‡ªåˆ†ã®ã‚¿ã‚¹ã‚¯ã®ã¿ã‚¢ã‚¯ã‚»ã‚¹å¯èƒ½
CREATE POLICY "Users can access own tasks" ON tasks
FOR ALL USING (user_id = auth.uid()::text OR user_id LIKE 'anon_%');
            `;
            
            console.log(message);
            alert('Supabaseã«tasksãƒ†ãƒ¼ãƒ–ãƒ«ã®ä½œæˆãŒå¿…è¦ã§ã™ã€‚ã‚³ãƒ³ã‚½ãƒ¼ãƒ«ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚');
        }

        function scheduleBatchSync() {
            if (syncTimer) clearTimeout(syncTimer);
            
            syncTimer = setTimeout(async () => {
                if (pendingSync.size > 0) {
                    await performBatchSync();
                }
            }, 1000);
        }

        async function performBatchSync() {
            if (!userId) {
                console.log('userIdãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚åŒæœŸã‚’ã‚¹ã‚­ãƒƒãƒ—');
                return;
            }
            
            if (!supabase) {
                localStorage.setItem('taskflow_tasks_' + userId, JSON.stringify(tasks));
                pendingSync.clear();
                showSyncIndicator('ãƒ­ãƒ¼ã‚«ãƒ«ä¿å­˜ã®ã¿', false, false, true);
                return;
            }

            try {
                const updates = Array.from(pendingSync).map(id => {
                    const task = tasks.find(t => t.id === id);
                    if (!task) return null;
                    
                    return {
                        id: task.id,
                        user_id: userId,
                        text: task.text,
                        status: task.status,
                        created_at: task.createdAt,
                        completed_at: task.completedAt,
                        order_index: task.order || 0,
                        memo: task.memo || '',
                        scheduled_date: task.scheduledDate
                    };
                }).filter(Boolean);

                if (updates.length > 0) {
                    console.log('Supabaseã«åŒæœŸä¸­:', updates.length, 'ä»¶');
                    const { error } = await supabase
                        .from('tasks')
                        .upsert(updates, { onConflict: 'id' });

                    if (error) {
                        console.error('Supabaseä¿å­˜ã‚¨ãƒ©ãƒ¼:', error);
                        console.log('ã‚¨ãƒ©ãƒ¼è©³ç´°:', error);
                        
                        // ãƒ†ãƒ¼ãƒ–ãƒ«ãŒå­˜åœ¨ã—ãªã„å ´åˆ
                        if (error.code === 'PGRST116' || error.message.includes('relation "tasks" does not exist') || error.code === '42P01') {
                            showSyncIndicator('ãƒ†ãƒ¼ãƒ–ãƒ«æœªä½œæˆã€ãƒ­ãƒ¼ã‚«ãƒ«ä¿å­˜ã®ã¿', false, false, true);
                        } else {
                            showSyncIndicator('åŒæœŸã‚¨ãƒ©ãƒ¼: ' + (error.message || error.code), true);
                        }
                    } else {
                        console.log('Supabaseä¿å­˜æˆåŠŸ:', updates.length, 'ä»¶');
                        showSyncIndicator('SupabaseåŒæœŸå®Œäº†', false, true);
                    }
                }
                
                pendingSync.clear();
                localStorage.setItem('taskflow_tasks_' + userId, JSON.stringify(tasks));
            } catch (error) {
                console.error('performBatchSync ã‚¨ãƒ©ãƒ¼:', error);
                showSyncIndicator('åŒæœŸã‚¨ãƒ©ãƒ¼', true);
                localStorage.setItem('taskflow_tasks_' + userId, JSON.stringify(tasks));
            }
        }

        async function addTask() {
            console.log('addTask é–¢æ•°å®Ÿè¡Œ');
            
            if (!userId) {
                console.error('userIdãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“');
                return;
            }
            
            const input = document.getElementById('newTask');
            if (!input) {
                console.error('å…¥åŠ›è¦ç´ ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
                return;
            }
            
            const text = input.value.trim();
            console.log('å…¥åŠ›ãƒ†ã‚­ã‚¹ãƒˆ:', text);
            
            if (!text) {
                console.log('ãƒ†ã‚­ã‚¹ãƒˆãŒç©ºã§ã™');
                return;
            }

            const task = {
                id: Date.now(),
                text: text,
                status: 'todo',
                createdAt: new Date().toISOString(),
                completedAt: null,
                order: tasks.length,
                memo: '',
                scheduledDate: null
            };

            console.log('æ–°ã—ã„ã‚¿ã‚¹ã‚¯:', task);
            
            tasks.push(task);
            input.value = '';
            renderTasks();

            console.log('ã‚¿ã‚¹ã‚¯è¿½åŠ å®Œäº†, ç·æ•°:', tasks.length);
            
            pendingSync.add(task.id);
            scheduleBatchSync();
        }

        async function changeStatus(id, newStatus) {
            console.log('ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹å¤‰æ›´:', id, newStatus);
            
            const task = tasks.find(t => t.id === id);
            if (!task) {
                console.error('ã‚¿ã‚¹ã‚¯ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“:', id);
                return;
            }
            
            task.status = newStatus;
            
            if (newStatus === 'completed') {
                task.completedAt = new Date().toISOString();
            } else {
                task.completedAt = null;
            }
            
            renderTasks();
            pendingSync.add(id);
            scheduleBatchSync();
        }

        async function deleteTask(id) {
            console.log('ã‚¿ã‚¹ã‚¯å‰Šé™¤:', id);
            
            if (!userId) {
                console.error('userIdãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“');
                return;
            }
            
            tasks = tasks.filter(t => t.id !== id);
            renderTasks();

            if (supabase) {
                try {
                    const { error } = await supabase
                        .from('tasks')
                        .delete()
                        .eq('id', id)
                        .eq('user_id', userId);
                    
                    if (error) {
                        console.error('å‰Šé™¤ã‚¨ãƒ©ãƒ¼:', error);
                    } else {
                        console.log('Supabaseã‹ã‚‰ã‚¿ã‚¹ã‚¯å‰Šé™¤å®Œäº†');
                    }
                } catch (error) {
                    console.error('å‰Šé™¤ã‚¨ãƒ©ãƒ¼:', error);
                }
            }

            localStorage.setItem('taskflow_tasks_' + userId, JSON.stringify(tasks));
        }

        function switchView(view) {
            currentView = view;
            document.querySelectorAll('.view-btn').forEach(btn => btn.classList.remove('active'));
            
            if (view === 'all') {
                document.querySelector('.view-btn[onclick="switchView(\'all\')"]').classList.add('active');
                document.getElementById('datePicker').classList.remove('show');
                document.getElementById('statusFilters').style.display = 'flex';
            } else if (view === 'date') {
                document.querySelector('.view-btn[onclick="switchView(\'date\')"]').classList.add('active');
                document.getElementById('datePicker').classList.add('show');
                document.getElementById('statusFilters').style.display = 'none';
                
                // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ä»Šæ—¥ã®æ—¥ä»˜ã‚’è¨­å®š
                const today = new Date().toISOString().split('T')[0];
                document.getElementById('viewDate').value = today;
                selectedDate = today;
            }
            
            renderTasks();
        }
        
        function setDateFilter() {
            const dateInput = document.getElementById('viewDate');
            selectedDate = dateInput.value;
            renderTasks();
        }
        
        function setFilter(filter) {
            console.log('ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼å¤‰æ›´:', filter);
            currentFilter = filter;
            document.querySelectorAll('.filter').forEach(f => f.classList.remove('active'));
            
            const filterTexts = {
                'all': 'ã‚¢ã‚¯ãƒ†ã‚£ãƒ–',
                'progress': 'é€²è¡Œä¸­', 
                'completed': 'å®Œäº†'
            };
            
            document.querySelectorAll('.filter').forEach(f => {
                if (f.textContent === filterTexts[filter]) {
                    f.classList.add('active');
                }
            });
            
            renderTasks();
        }

        function getFilteredTasks() {
            let filtered;
            
            if (currentView === 'date') {
                // æ—¥ä»˜ãƒ“ãƒ¥ãƒ¼ã®å ´åˆ
                if (!selectedDate) return [];
                
                filtered = tasks.filter(t => {
                    if (!t.scheduledDate) return false;
                    const taskDate = new Date(t.scheduledDate).toISOString().split('T')[0];
                    return taskDate === selectedDate;
                });
            } else {
                // å…¨ã‚¿ã‚¹ã‚¯ãƒ“ãƒ¥ãƒ¼ã®å ´åˆ
                if (currentFilter === 'all') {
                    filtered = tasks.filter(t => t.status !== 'completed');
                } else if (currentFilter === 'progress') {
                    filtered = tasks.filter(t => t.status === 'progress');
                } else if (currentFilter === 'completed') {
                    filtered = tasks.filter(t => t.status === 'completed');
                } else {
                    filtered = tasks;
                }
            }
            
            return filtered.sort((a, b) => {
                // é€²è¡Œä¸­ã‚’ä¸€ç•ªä¸Šã«
                if (a.status === 'progress' && b.status !== 'progress') return -1;
                if (b.status === 'progress' && a.status !== 'progress') return 1;
                // åœæ­¢ä¸­ã‚’æ¬¡ã«
                if (a.status === 'paused' && b.status !== 'paused' && b.status !== 'progress') return -1;
                if (b.status === 'paused' && a.status !== 'paused' && a.status !== 'progress') return 1;
                return (a.order || 0) - (b.order || 0);
            });
        }

        // ãƒ¡ãƒ¢ç·¨é›†é–¢é€£é–¢æ•°
        function openMemoEditor(taskId) {
            const task = tasks.find(t => t.id === taskId);
            if (!task) return;
            
            currentEditingMemo = taskId;
            
            const overlay = document.getElementById('memoOverlay');
            const titleElement = document.getElementById('memoTaskTitle');
            const editorElement = document.getElementById('memoEditor');
            const dateElement = document.getElementById('scheduleDate');
            const timeElement = document.getElementById('scheduleTime');
            
            titleElement.textContent = task.text;
            editorElement.value = task.memo || '';
            
            // æ—¥æ™‚ã®è¨­å®š
            if (task.scheduledDate) {
                const scheduled = new Date(task.scheduledDate);
                dateElement.value = scheduled.toISOString().split('T')[0];
                timeElement.value = scheduled.toTimeString().substr(0, 5);
            } else {
                dateElement.value = '';
                timeElement.value = '';
            }
            
            // éå»æ—¥ä»˜ã®è¨­å®šã‚’ç¦æ­¢
            const today = new Date().toISOString().split('T')[0];
            dateElement.min = today;
            
            overlay.classList.add('show');
            setTimeout(() => {
                editorElement.focus();
            }, 100);
        }
        
        function closeMemoEditor() {
            const overlay = document.getElementById('memoOverlay');
            overlay.classList.remove('show');
            currentEditingMemo = null;
            memoEditorSetup = false;
        }
        
        function saveMemo() {
            if (!currentEditingMemo) return;
            
            const task = tasks.find(t => t.id === currentEditingMemo);
            const editorElement = document.getElementById('memoEditor');
            const dateElement = document.getElementById('scheduleDate');
            const timeElement = document.getElementById('scheduleTime');
            
            if (task) {
                task.memo = editorElement.value;
                
                // æ—¥æ™‚ã®ä¿å­˜
                if (dateElement.value && timeElement.value) {
                    const scheduledDateTime = new Date(dateElement.value + 'T' + timeElement.value);
                    task.scheduledDate = scheduledDateTime.toISOString();
                } else if (dateElement.value) {
                    // æ™‚åˆ»ãŒæœªè¨­å®šã®å ´åˆã¯9:00ã‚’ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã«
                    const scheduledDateTime = new Date(dateElement.value + 'T09:00');
                    task.scheduledDate = scheduledDateTime.toISOString();
                } else {
                    task.scheduledDate = null;
                }
                
                pendingSync.add(currentEditingMemo);
                scheduleBatchSync();
            }
            
            closeMemoEditor();
            renderTasks(); // æ—¥æ™‚ã‚¢ã‚¤ã‚³ãƒ³ã®æ›´æ–°ã®ãŸã‚
        }
        
        // PCéŸ³å£°é€šçŸ¥æ©Ÿèƒ½
        function playNotificationSound() {
            try {
                // Web Audio APIã§ãƒ“ãƒ¼ãƒ—éŸ³ã‚’ç”Ÿæˆ
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.frequency.setValueAtTime(800, audioContext.currentTime); // 800Hzã®éŸ³
                gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
                
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.5);
                
                console.log('ğŸ”” ç¢ºèªãŒå¿…è¦ã§ã™ï¼');
            } catch (error) {
                console.log('éŸ³å£°é€šçŸ¥ãŒåˆ©ç”¨ã§ãã¾ã›ã‚“:', error);
            }
        }
        
        function formatScheduleDate(dateString) {
            if (!dateString) return '';
            const date = new Date(dateString);
            const today = new Date();
            const tomorrow = new Date(today);
            tomorrow.setDate(tomorrow.getDate() + 1);
            
            const dateOnly = date.toDateString();
            const todayOnly = today.toDateString();
            const tomorrowOnly = tomorrow.toDateString();
            
            const timeStr = date.toLocaleTimeString('ja-JP', { hour: '2-digit', minute: '2-digit' });
            
            if (dateOnly === todayOnly) {
                return `ä»Šæ—¥ ${timeStr}`;
            } else if (dateOnly === tomorrowOnly) {
                return `æ˜æ—¥ ${timeStr}`;
            } else {
                return `${date.getMonth() + 1}/${date.getDate()} ${timeStr}`;
            }
        }
        
        function clearSchedule() {
            document.getElementById('scheduleDate').value = '';
            document.getElementById('scheduleTime').value = '';
        }
        
        function insertMemoFormat(format) {
            const editor = document.getElementById('memoEditor');
            const start = editor.selectionStart;
            const end = editor.selectionEnd;
            const selectedText = editor.value.substring(start, end);
            let replacement = '';
            
            switch(format) {
                case 'bullet':
                    replacement = '\u2022 ' + (selectedText || 'ãƒ†ã‚­ã‚¹ãƒˆ');
                    break;
                case 'number':
                    replacement = '1. ' + (selectedText || 'ãƒ†ã‚­ã‚¹ãƒˆ');
                    break;
                case 'checkbox':
                    replacement = '\u2610 ' + (selectedText || 'ã‚¿ã‚¹ã‚¯');
                    break;
            }
            
            editor.value = editor.value.substring(0, start) + replacement + editor.value.substring(end);
            editor.focus();
            editor.setSelectionRange(start + replacement.length, start + replacement.length);
        }
        
        // ãƒ¡ãƒ¢ã‚¨ãƒ‡ã‚£ã‚¿ãƒ¼ã®ã‚¤ãƒ™ãƒ³ãƒˆå‡¦ç†
        let memoEditorSetup = false;
        
        function setupMemoEditor() {
            const editor = document.getElementById('memoEditor');
            if (!editor || memoEditorSetup) return;
            
            // ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ã®ã‚¯ãƒªãƒƒã‚¯ã‚¤ãƒ™ãƒ³ãƒˆ
            editor.addEventListener('click', function(e) {
                const clickPos = this.selectionStart;
                const lines = this.value.split('\n');
                let currentPos = 0;
                
                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i];
                    const lineEnd = currentPos + line.length;
                    
                    if (clickPos >= currentPos && clickPos <= lineEnd) {
                        // ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ã®ä½ç½®ã‚’ãƒã‚§ãƒƒã‚¯
                        const checkboxMatch = line.match(/^(\u2610|\u2611) /);
                        if (checkboxMatch) {
                            const checkboxPos = currentPos;
                            const checkboxEnd = currentPos + 2; // ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ + ã‚¹ãƒšãƒ¼ã‚¹
                            
                            // ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹éƒ¨åˆ†ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ãŸå ´åˆ
                            if (clickPos >= checkboxPos && clickPos <= checkboxEnd) {
                                e.preventDefault();
                                
                                // ãƒã‚§ãƒƒã‚¯çŠ¶æ…‹ã‚’åˆ‡ã‚Šæ›¿ãˆ
                                const newCheckbox = checkboxMatch[1] === '\u2610' ? '\u2611' : '\u2610';
                                const newLine = newCheckbox + line.substring(1);
                                lines[i] = newLine;
                                
                                this.value = lines.join('\n');
                                this.setSelectionRange(clickPos, clickPos);
                                return;
                            }
                        }
                        break;
                    }
                    currentPos = lineEnd + 1; // +1 for newline character
                }
            });
            
            editor.addEventListener('keydown', function(e) {
                if (e.key === 'Enter') {
                    const start = this.selectionStart;
                    const lines = this.value.substring(0, start).split('\n');
                    const currentLine = lines[lines.length - 1];
                    
                    // ç©ºã®ãƒªã‚¹ãƒˆé …ç›®ã®å ´åˆã¯ç¶™ç¶šã—ãªã„
                    if (currentLine === '\u2022 ' || currentLine === '\u2610 ' || currentLine.match(/^\d+\. $/)) {
                        e.preventDefault();
                        // ç©ºã®ãƒªã‚¹ãƒˆé …ç›®ã‚’å‰Šé™¤ã—ã¦é€šå¸¸ã®æ”¹è¡Œ
                        const beforeCursor = this.value.substring(0, start - currentLine.length);
                        const afterCursor = this.value.substring(start);
                        this.value = beforeCursor + '\n' + afterCursor;
                        this.setSelectionRange(start - currentLine.length + 1, start - currentLine.length + 1);
                        return;
                    }
                    
                    // ç®‡æ¡æ›¸ãã®ç¶™ç¶š
                    if (currentLine.match(/^\u2022 .+/)) {
                        e.preventDefault();
                        const afterCursor = this.value.substring(start);
                        this.value = this.value.substring(0, start) + '\n\u2022 ' + afterCursor;
                        this.setSelectionRange(start + 3, start + 3);
                        return;
                    }
                    
                    // ç•ªå·ä»˜ããƒªã‚¹ãƒˆã®ç¶™ç¶š
                    const numberMatch = currentLine.match(/^(\d+)\. .+/);
                    if (numberMatch) {
                        e.preventDefault();
                        const nextNumber = parseInt(numberMatch[1]) + 1;
                        const afterCursor = this.value.substring(start);
                        this.value = this.value.substring(0, start) + '\n' + nextNumber + '. ' + afterCursor;
                        const newPos = start + nextNumber.toString().length + 3;
                        this.setSelectionRange(newPos, newPos);
                        return;
                    }
                    
                    // ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ã®ç¶™ç¶š
                    if (currentLine.match(/^[\u2610\u2611] .+/)) {
                        e.preventDefault();
                        const afterCursor = this.value.substring(start);
                        this.value = this.value.substring(0, start) + '\n\u2610 ' + afterCursor;
                        this.setSelectionRange(start + 3, start + 3);
                        return;
                    }
                }
            });
            
            memoEditorSetup = true;
        }
        
        // ãƒ¡ãƒ¢ã‚¢ã‚¤ã‚³ãƒ³ã‚¯ãƒªãƒƒã‚¯ãƒãƒ³ãƒ‰ãƒ©
        function handleMemoClick(taskId, event) {
            event.stopPropagation();
            event.preventDefault();
            openMemoEditor(taskId);
        }
        
        // ã‚¿ã‚¹ã‚¯åç·¨é›†ï¼ˆãƒ€ãƒ–ãƒ«ã‚¿ãƒƒãƒ—ã§ç¢ºå®Ÿã«ç·¨é›†ï¼‰
        let lastTapTime = 0;
        let lastTapTarget = null;
        
        function handleTaskTextTouch(id, event) {
            event.stopPropagation();
            event.preventDefault();
            
            const currentTime = Date.now();
            const timeDiff = currentTime - lastTapTime;
            
            // ãƒ€ãƒ–ãƒ«ã‚¿ãƒƒãƒ—åˆ¤å®šï¼ˆ500msä»¥å†…ã®2å›ã‚¿ãƒƒãƒ—ï¼‰
            if (timeDiff < 500 && lastTapTarget === id) {
                editTaskName(id, event);
                lastTapTime = 0; // ãƒªã‚»ãƒƒãƒˆ
                lastTapTarget = null;
            } else {
                lastTapTime = currentTime;
                lastTapTarget = id;
            }
        }

        function editTaskName(id, event) {
            // ã‚¤ãƒ™ãƒ³ãƒˆã®ä¼æ’­ã‚’åœæ­¢ã—ã¦ãƒ‰ãƒ©ãƒƒã‚°ã‚¤ãƒ™ãƒ³ãƒˆã¨ã®å¹²æ¸‰ã‚’é˜²ã
            if (event) {
                event.stopPropagation();
                event.preventDefault();
            }
            
            const task = tasks.find(t => t.id === id);
            const taskElement = document.querySelector(`[data-task-id="${id}"] .task-text`);
            
            if (!task || !taskElement) {
                console.error('ç·¨é›†å¯¾è±¡ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“:', id);
                return;
            }
            
            // æ—¢ã«ç·¨é›†ä¸­ã®å ´åˆã¯ä½•ã‚‚ã—ãªã„
            if (taskElement.classList.contains('editing')) {
                return;
            }
            
            // ã‚¤ãƒ³ãƒ©ã‚¤ãƒ³ç·¨é›†ã®æº–å‚™
            const originalText = task.text;
            taskElement.contentEditable = true;
            taskElement.classList.add('editing');
            
            // ãƒ•ã‚©ãƒ¼ã‚«ã‚¹ã¨ãƒ†ã‚­ã‚¹ãƒˆé¸æŠ
            taskElement.focus();
            
            // ãƒ¢ãƒã‚¤ãƒ«ã§ã®ãƒ†ã‚­ã‚¹ãƒˆé¸æŠã‚’ç¢ºå®Ÿã«
            if (isMobile) {
                setTimeout(() => {
                    const range = document.createRange();
                    range.selectNodeContents(taskElement);
                    const selection = window.getSelection();
                    selection.removeAllRanges();
                    selection.addRange(range);
                }, 50);
            } else {
                // PCç”¨
                const range = document.createRange();
                range.selectNodeContents(taskElement);
                const selection = window.getSelection();
                selection.removeAllRanges();
                selection.addRange(range);
            }
            
            function finishEdit() {
                const newText = taskElement.textContent.trim();
                if (newText && newText !== originalText) {
                    task.text = newText;
                    pendingSync.add(id);
                    scheduleBatchSync();
                } else if (!newText) {
                    // ç©ºã®å ´åˆã¯å…ƒã®ãƒ†ã‚­ã‚¹ãƒˆã«æˆ»ã™
                    task.text = originalText;
                }
                
                taskElement.contentEditable = false;
                taskElement.classList.remove('editing');
                renderTasks();
            }
            
            // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
            function onBlur() {
                finishEdit();
                cleanup();
            }
            
            function onKeyDown(e) {
                e.stopPropagation();
                if (e.key === 'Enter') {
                    e.preventDefault();
                    finishEdit();
                } else if (e.key === 'Escape') {
                    taskElement.textContent = originalText;
                    finishEdit();
                }
            }
            
            function cleanup() {
                taskElement.removeEventListener('blur', onBlur);
                taskElement.removeEventListener('keydown', onKeyDown);
            }
            
            taskElement.addEventListener('blur', onBlur);
            taskElement.addEventListener('keydown', onKeyDown);
        }

        // ãƒ‰ãƒ©ãƒƒã‚°&ãƒ‰ãƒ­ãƒƒãƒ—å‡¦ç†ï¼ˆPC + ã‚¹ãƒãƒ›å¯¾å¿œï¼‰
        function handleDragStart(e, index) {
            // ãƒ‰ãƒ©ãƒƒã‚°ãƒãƒ³ãƒ‰ãƒ«ã‹ã‚‰ã®ã¿ãƒ‰ãƒ©ãƒƒã‚°ã‚’è¨±å¯
            if (!e.target.closest('.drag-handle')) {
                e.preventDefault();
                return false;
            }
            
            draggedTaskIndex = index;
            e.target.closest('.task').classList.add('dragging');
            if (e.dataTransfer) {
                e.dataTransfer.effectAllowed = 'move';
            }
        }

        function handleTouchStart(e, index) {
            // ãƒ‰ãƒ©ãƒƒã‚°ãƒãƒ³ãƒ‰ãƒ«ã‹ã‚‰ã®ã¿ãƒ‰ãƒ©ãƒƒã‚°ã‚’è¨±å¯
            if (!e.target.closest('.drag-handle')) {
                return;
            }
            
            draggedTaskIndex = index;
            isTouching = true;
            touchStartY = e.touches[0].clientY;
            touchCurrentY = touchStartY;
            
            const taskElement = e.target.closest('.task');
            if (taskElement) {
                taskElement.classList.add('dragging');
                navigator.vibrate && navigator.vibrate(50); // æŒ¯å‹•ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯
                e.preventDefault();
            }
        }

        function handleTouchMove(e) {
            if (!isTouching || draggedTaskIndex === null) return;
            
            touchCurrentY = e.touches[0].clientY;
            const moveDistance = touchCurrentY - touchStartY;
            
            // ãƒ‰ãƒ©ãƒƒã‚°ãŒé–‹å§‹ã•ã‚Œã¦ã„ã‚‹å ´åˆã®ã¿å‡¦ç†
            const draggedElement = document.querySelector('.task.dragging');
            if (draggedElement) {
                e.preventDefault();
                draggedElement.style.transform = `translateY(${moveDistance}px) rotate(2deg)`;
                draggedElement.style.zIndex = '1000';
                
                // ç§»å‹•è·é›¢ãŒä¸€å®šä»¥ä¸Šã®å ´åˆã€ãƒ‰ãƒ©ãƒƒã‚°ä¸­ã§ã‚ã‚‹ã“ã¨ã‚’ç¤ºã™
                if (Math.abs(moveDistance) > 10) {
                    draggedElement.style.opacity = '0.7';
                    updateDropTarget(moveDistance);
                }
            }
        }
        
        function updateDropTarget(moveDistance) {
            // æ—¢å­˜ã®ãƒ‰ãƒ­ãƒƒãƒ—ã‚¿ãƒ¼ã‚²ãƒƒãƒˆè¡¨ç¤ºã‚’ã‚¯ãƒªã‚¢
            document.querySelectorAll('.task').forEach(task => {
                task.classList.remove('drag-target-above', 'drag-target-below');
            });
            
            if (Math.abs(moveDistance) < 20) return;
            
            const taskHeight = 60;
            const moveSteps = Math.round(moveDistance / taskHeight);
            const filteredTasks = getFilteredTasks();
            const newIndex = Math.max(0, Math.min(filteredTasks.length - 1, draggedTaskIndex + moveSteps));
            
            if (newIndex !== draggedTaskIndex && newIndex < filteredTasks.length) {
                const targetTask = filteredTasks[newIndex];
                const targetElement = document.querySelector(`[data-task-id="${targetTask.id}"]`);
                
                if (targetElement) {
                    if (moveDistance > 0) {
                        // ä¸‹ã«ç§»å‹•
                        targetElement.classList.add('drag-target-below');
                    } else {
                        // ä¸Šã«ç§»å‹•
                        targetElement.classList.add('drag-target-above');
                    }
                }
            }
        }

        function handleTouchEnd(e) {
            if (!isTouching || draggedTaskIndex === null) {
                cleanupDragState();
                return;
            }
            
            const draggedElement = document.querySelector('.task.dragging');
            if (draggedElement) {
                e.preventDefault();
                
                const moveDistance = touchCurrentY - touchStartY;
                
                // ãƒ‰ãƒ­ãƒƒãƒ—å‡¦ç†ã®å®Ÿè¡Œ
                if (Math.abs(moveDistance) > 20) {
                    const taskHeight = 60;
                    const moveSteps = Math.round(moveDistance / taskHeight);
                    const filteredTasks = getFilteredTasks();
                    const newIndex = Math.max(0, Math.min(filteredTasks.length - 1, draggedTaskIndex + moveSteps));
                    
                    console.log('ãƒ‰ãƒ©ãƒƒã‚°çµ‚äº†:', draggedTaskIndex, '->', newIndex, 'ç§»å‹•è·é›¢:', moveDistance);
                    
                    if (newIndex !== draggedTaskIndex) {
                        handleDropLogic(draggedTaskIndex, newIndex);
                        navigator.vibrate && navigator.vibrate(100); // æˆåŠŸæ™‚ã®æŒ¯å‹•ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯
                        console.log('ä¸¦ã³æ›¿ãˆå®Ÿè¡Œæ¸ˆã¿');
                    } else {
                        console.log('ä¸¦ã³æ›¿ãˆãªã—ï¼ˆåŒã˜ä½ç½®ï¼‰');
                    }
                } else {
                    console.log('ç§»å‹•è·é›¢ä¸è¶³:', moveDistance);
                }
            }
            
            // ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—ã‚’æœ€å¾Œã«å®Ÿè¡Œ
            cleanupDragState();
        }
        
        function cleanupDragState() {
            console.log('ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—å®Ÿè¡Œ');
            
            isTouching = false;
            draggedTaskIndex = null;
            touchStartY = 0;
            touchCurrentY = 0;
            
            // å…¨ã¦ã®ãƒ‰ãƒ©ãƒƒã‚°é–¢é€£ã‚¯ãƒ©ã‚¹ã¨ã‚¹ã‚¿ã‚¤ãƒ«ã‚’ã‚¯ãƒªã‚¢
            document.querySelectorAll('.task').forEach(task => {
                task.classList.remove('dragging', 'drag-target-above', 'drag-target-below');
                task.style.transform = '';
                task.style.zIndex = '';
                task.style.opacity = '';
            });
        }

        function handleDragOver(e, index) {
            e.preventDefault();
            if (e.dataTransfer) {
                e.dataTransfer.dropEffect = 'move';
            }
            
            if (draggedTaskIndex !== null && draggedTaskIndex !== index) {
                e.target.closest('.task').classList.add('drag-over');
            }
        }

        function handleDragLeave(e) {
            e.target.closest('.task').classList.remove('drag-over');
        }

        function handleDrop(e, dropIndex) {
            e.preventDefault();
            e.target.closest('.task').classList.remove('drag-over');
            
            if (draggedTaskIndex !== null && draggedTaskIndex !== dropIndex) {
                handleDropLogic(draggedTaskIndex, dropIndex);
            }
        }

        function handleDropLogic(fromIndex, toIndex) {
            console.log('ä¸¦ã³æ›¿ãˆãƒ­ã‚¸ãƒƒã‚¯é–‹å§‹:', fromIndex, '->', toIndex);
            
            const filtered = getFilteredTasks();
            const draggedTask = filtered[fromIndex];
            const dropTask = filtered[toIndex];
            
            console.log('ãƒ‰ãƒ©ãƒƒã‚°ã‚¿ã‚¹ã‚¯:', draggedTask?.text, 'ãƒ‰ãƒ­ãƒƒãƒ—ã‚¿ã‚¹ã‚¯:', dropTask?.text);
            
            if (!draggedTask || !dropTask) {
                console.log('ã‚¿ã‚¹ã‚¯ãŒè¦‹ã¤ã‹ã‚‰ãªã„');
                return;
            }
            
            // ç°¡ç´ åŒ–ã—ãŸä¸¦ã³æ›¿ãˆãƒ­ã‚¸ãƒƒã‚¯
            const draggedTaskId = draggedTask.id;
            const allTasks = [...tasks];
            
            console.log('ä¸¦ã³æ›¿ãˆå‰ã®ã‚¿ã‚¹ã‚¯æ•°:', allTasks.length);
            
            // å…ƒã®é…åˆ—ã‹ã‚‰ãƒ‰ãƒ©ãƒƒã‚°ã•ã‚ŒãŸã‚¿ã‚¹ã‚¯ã‚’å‰Šé™¤
            const draggedOriginalIndex = allTasks.findIndex(t => t.id === draggedTaskId);
            const removedTask = allTasks.splice(draggedOriginalIndex, 1)[0];
            
            // æ–°ã—ã„ä½ç½®ã«æŒ¿å…¥
            const dropOriginalIndex = allTasks.findIndex(t => t.id === dropTask.id);
            allTasks.splice(dropOriginalIndex, 0, removedTask);
            
            // orderå€¤ã‚’å†è¨­å®š
            allTasks.forEach((task, index) => {
                task.order = index;
            });
            
            tasks = allTasks;
            
            console.log('ä¸¦ã³æ›¿ãˆå¾Œã®ã‚¿ã‚¹ã‚¯æ•°:', tasks.length);
            console.log('ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°é–‹å§‹');
            
            renderTasks();
            
            pendingSync.add(draggedTaskId);
            scheduleBatchSync();
            
            console.log('ä¸¦ã³æ›¿ãˆå®Œäº†');
        }

        function handleDragEnd(e) {
            e.target.classList.remove('dragging');
            document.querySelectorAll('.task').forEach(task => {
                task.classList.remove('drag-over', 'drag-target-above', 'drag-target-below');
            });
            draggedTaskIndex = null;
        }

        function getTaskActions(task) {
            let actions = '';
            
            if (task.status === 'todo') {
                actions += `<button class="start" onclick="changeStatus(${task.id}, 'progress')" title="é–‹å§‹">â–·</button>`;
                actions += `<button class="complete" onclick="changeStatus(${task.id}, 'completed')" title="å®Œäº†">âœ“</button>`;
            } else if (task.status === 'progress') {
                actions += `<button class="back" onclick="changeStatus(${task.id}, 'todo')" title="æˆ»ã™">â¸</button>`;
                actions += `<button class="pause" onclick="changeStatus(${task.id}, 'paused')" title="åœæ­¢">â¹</button>`;
                actions += `<button class="complete" onclick="changeStatus(${task.id}, 'completed')" title="å®Œäº†">âœ“</button>`;
            } else if (task.status === 'paused') {
                actions += `<button class="start" onclick="changeStatus(${task.id}, 'progress')" title="å†é–‹">â–·</button>`;
            } else if (task.status === 'completed') {
                actions += `<button class="back" onclick="changeStatus(${task.id}, 'todo')" title="å†é–‹">â†»</button>`;
            }
            
            actions += `<button class="delete" onclick="deleteTask(${task.id})" title="å‰Šé™¤">Ã—</button>`;
            return actions;
        }

        function renderTasks() {
            console.log('renderTasks å®Ÿè¡Œ, ã‚¿ã‚¹ã‚¯æ•°:', tasks.length);
            
            const filtered = getFilteredTasks();
            console.log('ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼å¾Œ:', filtered.length);

            const html = filtered.length ? filtered.map((task, index) => 
                `<div class="task ${task.status}" 
                     data-task-id="${task.id}"
                     draggable="true"
                     ondragstart="handleDragStart(event, ${index})"
                     ondragover="handleDragOver(event, ${index})"
                     ondragleave="handleDragLeave(event)"
                     ondrop="handleDrop(event, ${index})"
                     ondragend="handleDragEnd(event)"
                     ontouchstart="handleTouchStart(event, ${index})"
                     ontouchmove="handleTouchMove(event)"
                     ontouchend="handleTouchEnd(event)">
                    <div class="drag-handle" title="ãƒ‰ãƒ©ãƒƒã‚°ã—ã¦ä¸¦ã³æ›¿ãˆ">â˜°</div>
                    <div class="task-content">
                        <div class="task-text" ${isMobile ? `ontouchend="handleTaskTextTouch(${task.id}, event)"` : `onclick="editTaskName(${task.id}, event)"`} title="${isMobile ? 'ãƒ€ãƒ–ãƒ«ã‚¿ãƒƒãƒ—ã§ç·¨é›†' : 'ã‚¯ãƒªãƒƒã‚¯ã—ã¦ç·¨é›†'}">
                            ${task.text}
                            ${task.scheduledDate ? `<span class="schedule-icon" title="äºˆå®š: ${formatScheduleDate(task.scheduledDate)}">ğŸ“…</span>` : ''}
                        </div>
                    </div>
                    <div class="memo-icon ${task.memo && task.memo.trim() ? 'has-memo' : ''}" onclick="handleMemoClick(${task.id}, event)" title="ãƒ¡ãƒ¢ã‚’ç·¨é›†">ğŸ“</div>
                    <div class="task-actions">
                        ${getTaskActions(task)}
                    </div>
                </div>`
            ).join('') : '<div class="empty">ã‚¿ã‚¹ã‚¯ãŒã‚ã‚Šã¾ã›ã‚“</div>';

            const taskList = document.getElementById('taskList');
            if (taskList) {
                taskList.innerHTML = html;
                console.log('HTMLæ›´æ–°å®Œäº†');
            } else {
                console.error('taskListè¦ç´ ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
            }
            
            updateStats();
        }

        function updateStats() {
            const totalElement = document.getElementById('totalTasks');
            const progressElement = document.getElementById('progressTasks');
            const completedElement = document.getElementById('completedTasks');
            
            if (totalElement) totalElement.textContent = tasks.filter(t => t.status !== 'completed').length;
            if (progressElement) progressElement.textContent = tasks.filter(t => t.status === 'progress').length;
            if (completedElement) completedElement.textContent = tasks.filter(t => t.status === 'completed').length;
        }

        // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
        document.addEventListener('DOMContentLoaded', () => {
            console.log('DOMèª­ã¿è¾¼ã¿å®Œäº†');
            
            const newTaskInput = document.getElementById('newTask');
            if (newTaskInput) {
                newTaskInput.addEventListener('keypress', e => {
                    if (e.key === 'Enter') {
                        console.log('Enterã‚­ãƒ¼æŠ¼ä¸‹');
                        addTask();
                    }
                });
            } else {
                console.error('newTaskè¦ç´ ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
            }
            
            // SupabaseåˆæœŸåŒ–å®Œäº†ã¾ã§å°‘ã—å¾…æ©Ÿã—ã¦ã‹ã‚‰åˆæœŸåŒ–
            console.log('åˆæœŸåŒ–é–‹å§‹');
            setTimeout(() => {
                if (!userId) {
                    // userIdãŒè¨­å®šã•ã‚Œã¦ã„ãªã„å ´åˆã¯ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
                    userId = localStorage.getItem('todo_anon_user_id') || generateUserId();
                }
                loadTasks();
                // ãƒ¡ãƒ¢ã‚¨ãƒ‡ã‚£ã‚¿ãƒ¼ã®åˆæœŸè¨­å®š
                setupMemoEditor();
            }, 100);
        });

        window.addEventListener('beforeunload', () => {
            if (pendingSync.size > 0) {
                localStorage.setItem('taskflow_tasks_' + userId, JSON.stringify(tasks));
            }
        });
        
        // ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦å…¨ä½“ã§ã®touchendã‚¤ãƒ™ãƒ³ãƒˆï¼ˆãƒ•ãƒªãƒ¼ã‚ºé˜²æ­¢ï¼‰
        window.addEventListener('touchend', (e) => {
            if (isTouching || document.querySelector('.task.dragging')) {
                cleanupDragState();
            }
        });
        
        // ç”»é¢å¤–ã¸ã®ãƒ‰ãƒ©ãƒƒã‚°ã§ã‚‚ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
        window.addEventListener('touchcancel', (e) => {
            cleanupDragState();
        });
        
        // ãƒ¡ãƒ¢ãƒ¢ãƒ¼ãƒ€ãƒ«ã®ã‚¯ãƒªãƒƒã‚¯ã‚¤ãƒ™ãƒ³ãƒˆå‡¦ç†
        document.addEventListener('click', (e) => {
            const overlay = document.getElementById('memoOverlay');
            if (e.target === overlay) {
                closeMemoEditor();
            }
        });
        
        // ESCã‚­ãƒ¼ã§ãƒ¡ãƒ¢ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’é–‰ã˜ã‚‹
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && document.getElementById('memoOverlay').classList.contains('show')) {
                closeMemoEditor();
            }
        });
    </script>
</body>
</html>